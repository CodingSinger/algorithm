[维基百科](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。 子问题往往就是一个大问题的部分数据的相同问题，
例如找两个字符串的相同子串，则从两个字符串长度[0..l]之间找到相同子串。从较小子问题，依次推出各大的子问题，这其实是状态转移的过程，而状态就是每个子问题需要保留的当前答案，该答案
使后续子问题可以关注当前而不需要关注过去。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

    # 等效于 s反过来 s' 求两个字符串的最长子串
    #
    # ①首先拆分成子问题 ： 即求两个字符串的子串的最长公共子串 因为该子串会影响下一个子串 则需要保存n*n(n表示长度)种可能的状态 即x[i][j]
    # ②找到状态定义：x[i+1][j+1]
    # 表示以s[i]和s'[j]结尾的最长子串长串，为什么以是以s[i]和s'[j]结尾的最长子串呢 这样才能以当前状态推出下一个状态 即当s[i+1] == s'[j+1]时，则在s[0..i]和s'[0..j]中
    # 此时最长子串一定为x[i][j]+1
    # ③找到状态转移方程 因为
    # if s[i] == s'[j] x[i+1][j+1] = x[i][j]+1
    # else: x[i+1][j+1] =1

```python
    def helper1(self, s):
        ls = len(s)
        x = [[0 for i in range(ls+1)] for j in range(ls+1)]
        rs = s[::-1]

        # 查找公共子串

        ans, start, end, res = 1, 0, 0, ""
        for i in range(ls):
            for j in range(ls):
                if s[i] == rs[j]:
                    x[i+1][j+1] = x[i][j] + 1
                    if ans <= x[i+1][j+1]:
                        # 检查是不是回文
                        temp = s[i - x[i+1][j+1] + 1:i + 1]
                        if temp == temp[::-1]:
                            res = temp
                            ans = x[i+1][j+1]

        return res
```